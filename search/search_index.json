{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RecoNER, Debug annotated Named Entity Recognition (NER) data for inconsitencies and get insights on improving the quality of your data. Documentation : https://kabirkhan.github.io/reconer Source Code : https://github.com/kabirkhan/reconer RecoNER is a library to help you fix your annotated NER data and identify examples that are hardest for your model to predict so you can strategically prioritize the examples you annotate. The key features are: Data Validation and Cleanup : Easily Validate the format of your NER data. Filter overlapping Entity Annotations, fix missing properties. Model Insights : Analyze how well your model does on your Dataset. Identify the top errors your model is making so you can prioritize data collection and correction strategically. Model Insights : Analyze how well your model does on your Dataset. Identify the top errors your model is making so you can prioritize data collection and correction strategically. Dataset Management : reconer provides a Dataset class to manage the train/dev/test split of your data and apply the same functions across all splits in your data + a concatenation of all examples. Operate inplace to consistently transform your data. Serializable Dataset : Serialize and Deserialize your data to and from JSON to the reconer type system. Type Hints : Comprehensive Typing system based on Python 3.6+ Type Hints Requirements \u00b6 Python 3.6+ Python 3.6+ RecoNER is built on a few comprehensive, high-performing packages. spaCy Pydantic (Type system and JSON Serialization) Typer (CLI) . Installation \u00b6 $ pip install reconer ---> 100% Successfully installed reconer License \u00b6 This project is licensed under the terms of the MIT license.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+ Python 3.6+ RecoNER is built on a few comprehensive, high-performing packages. spaCy Pydantic (Type system and JSON Serialization) Typer (CLI) .","title":"Requirements"},{"location":"#installation","text":"$ pip install reconer ---> 100% Successfully installed reconer","title":"Installation"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"contributing/","text":"First, you might want to see the basic ways to help Typer and get help . Coming soon...","title":"Development - Contributing"},{"location":"features/","text":"Design based on FastAPI \u00b6 Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less. Just Modern Python \u00b6 It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . Editor support \u00b6 Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc. Short \u00b6 It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" . User friendly CLI apps \u00b6 The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work. The power of Click \u00b6 Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"Features"},{"location":"features/#design-based-on-fastapi","text":"Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less.","title":"Design based on FastAPI"},{"location":"features/#just-modern-python","text":"It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro .","title":"Just Modern Python"},{"location":"features/#editor-support","text":"Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc.","title":"Editor support"},{"location":"features/#short","text":"It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" .","title":"Short"},{"location":"features/#user-friendly-cli-apps","text":"The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work.","title":"User friendly CLI apps"},{"location":"features/#the-power-of-click","text":"Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"The power of Click"},{"location":"release-notes/","text":"0.0.1 \u00b6 First commit. Publish to PyPI to reserve package name. Initial Functionality for Validation, Insights, Dataset Managment, Serialization and Deserialization from JSON files, Type System","title":"Release Notes"},{"location":"release-notes/#001","text":"First commit. Publish to PyPI to reserve package name. Initial Functionality for Validation, Insights, Dataset Managment, Serialization and Deserialization from JSON files, Type System","title":"0.0.1"},{"location":"api/dataset/","text":"reconer.dataset.Dataset \u00b6 reconer.dataset.Dataset is a container to run other reconer operations across your train/dev/test split The reconer.dataset.Dataset.apply function takes any of the other reconer functions and runs them on all the datasets in sequence. API \u00b6 class reconer. Dataset ( train , dev , test=None ) Container for a full dataset with train/dev/test splits. Used to apply core functions to all datasets at once. Parameters \u00b6 train : (List[Example]), required. List of Examples for train set dev : (List[Example]), required. List of Examples for dev set test : (List[Example], optional), Defaults to None. List of Examples for test set apply ( self , func , *args , **kwargs ) Apply an existing function to all datasets Parameters \u00b6 func : (Callable[[List[Example]], Any]), required. Function from an existing reconer module that can operate on a List of Examples Returns \u00b6 (Dict[str, List[Example]]): Dictionary mapping dataset names to List[Example], same as the internal datasets property from_disk ( path , loader_func= ) Load Dataset from disk given a directory with files named explicitly train.jsonl, dev.jsonl, and test.jsonl Parameters \u00b6 path : (Path), required. directory to load from loader_func : (Callable, optional), Defaults to read_jsonl. Loader function (TODO: Make this a bit more generic)","title":"Dataset"},{"location":"api/dataset/#reconerdatasetdataset","text":"reconer.dataset.Dataset is a container to run other reconer operations across your train/dev/test split The reconer.dataset.Dataset.apply function takes any of the other reconer functions and runs them on all the datasets in sequence.","title":"reconer.dataset.Dataset"},{"location":"api/dataset/#api","text":"class reconer. Dataset ( train , dev , test=None ) Container for a full dataset with train/dev/test splits. Used to apply core functions to all datasets at once.","title":"API"},{"location":"api/insights/","text":"reconer.insights \u00b6 The reconer.insights module provides more complex functionality for understanding your dataset. It provides functions for identifying disparities in your annotations and identifying the kinds of examples and labels that are hardest for your model to identify. Some of the functionality in reconer.insights require a reconer.recognizer.EntityRecognizer object. You can read more about the EntityRecognizer class here: Tutorial - Custom EntityRecognizer API \u00b6 reconer.insights. ents_by_label ( data , use_lower=True ) Get a dictionary of unique text spans by label for your data Parameters \u00b6 data : (List[Example]), required. List of Examples use_lower : (bool, optional), Defaults to True. Use the lowercase form of the span text Returns \u00b6 (DefaultDict[str, List[str]]): DefaultDict mapping label to sorted list of the unique spans annotated for that label. reconer.insights. get_label_disparities ( data , label1 , label2 , use_lower=True ) Identify annotated spans that have different labels in different examples Parameters \u00b6 data : (List[Example]), required. Input List of Examples label1 : (str), required. First label to compare label2 : (str), required. Second label to compare Returns \u00b6 (Set[str]): Set of all unique text spans that overlap between label1 and label2 reconer.insights. top_prediction_errors ( ner , data , labels=None , k=None , exclude_fp=False , exclude_fn=False ) Get a sorted list of examples your model is worst at predicting. Parameters \u00b6 ner : (EntityRecognizer), required. An instance of EntityRecognizer data : (List[Example]), required. List of annotated Examples labels : (List[str], optional), Defaults to None. List of labels to get errors for. Defaults to the labels property of ner . k : (int, optional), Defaults to None. If set, return the top k prediction errors, otherwise the whole list. exclude_fp : (bool, optional), Defaults to False. Flag to exclude False Positive errors. exclude_fn : (bool, optional), Defaults to False. Flag to exclude False Negative errors. Returns \u00b6 (List[PredictionError]): [description]","title":"Insights"},{"location":"api/insights/#reconerinsights","text":"The reconer.insights module provides more complex functionality for understanding your dataset. It provides functions for identifying disparities in your annotations and identifying the kinds of examples and labels that are hardest for your model to identify. Some of the functionality in reconer.insights require a reconer.recognizer.EntityRecognizer object. You can read more about the EntityRecognizer class here: Tutorial - Custom EntityRecognizer","title":"reconer.insights"},{"location":"api/insights/#api","text":"reconer.insights. ents_by_label ( data , use_lower=True ) Get a dictionary of unique text spans by label for your data","title":"API"},{"location":"api/stats/","text":"reconer.stats \u00b6 The stats module implements utility functions for getting statistics for an NER dataset. It's useful for getting a quick overview of your data and checking that you have enough examples for each label (including examples with NO ENTITIES ) API \u00b6 reconer.stats. ner_stats ( data , serialize=False , no_print=False ) Compute statistics for NER data Parameters \u00b6 data : (List[Example]), required. Data as a List of Examples serialize : (bool, optional), Defaults to False. Serialize to a JSON string for printing no_print : (bool, optional), Defaults to False. Don't print, return serialized string. Requires serialize to be True Returns \u00b6 (List[Example]): List of examples or string if serialize and no_print are both True","title":"Stats"},{"location":"api/stats/#reconerstats","text":"The stats module implements utility functions for getting statistics for an NER dataset. It's useful for getting a quick overview of your data and checking that you have enough examples for each label (including examples with NO ENTITIES )","title":"reconer.stats"},{"location":"api/stats/#api","text":"reconer.stats. ner_stats ( data , serialize=False , no_print=False ) Compute statistics for NER data","title":"API"},{"location":"api/validation/","text":"reconer.validation \u00b6 reconer.validation provides a set of utility functions to fix and validate annotations to ensure consistency and no overlapping entities are set. These functions are useful to run before any of the functionality in reconer.insights or reconer.stats . API \u00b6 reconer.validation. json_to_examples ( data ) Convert List of Dicts to List of typed Examples Parameters \u00b6 data : (List[Dict[str, Any]]), required. Input List of Dicts to convert Returns \u00b6 (List[Example]): List of typed Examples reconer.validation. fix_annotations_format ( data ) Fix annotations format for a consistent dataset Parameters \u00b6 data : (List[Dict[str, Any]]), required. List of Examples Returns \u00b6 (List[Dict[str, Any]]): List of Examples with corrected formatting reconer.validation. filter_overlaps ( data ) Filter overlapping entity spans by picking the longest one. Parameters \u00b6 data : (List[Dict[str, Any]]), required. List of Examples Returns \u00b6 (List[Dict[str, Any]]): List of Examples with fixed overlaps","title":"Validation"},{"location":"api/validation/#reconervalidation","text":"reconer.validation provides a set of utility functions to fix and validate annotations to ensure consistency and no overlapping entities are set. These functions are useful to run before any of the functionality in reconer.insights or reconer.stats .","title":"reconer.validation"},{"location":"api/validation/#api","text":"reconer.validation. json_to_examples ( data ) Convert List of Dicts to List of typed Examples","title":"API"}]}