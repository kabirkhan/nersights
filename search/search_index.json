{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Typer, build great CLIs. Easy to code. Based on Python type hints. Documentation : https://typer.tiangolo.com Source Code : https://github.com/tiangolo/typer Typer is library to build CLI applications that users will love using and developers will love creating. Based on Python 3.6+ type hints. Typer is FastAPI 's little sibling. And it's intended to be the FastAPI of CLIs. The key features are: Intuitive to write : Great editor support. Completion everywhere. Less time debugging. Designed to be easy to use and learn. Less time reading docs. Easy to use : It's easy to use for the final users. Automatic help, and (optional) automatic completion for all shells. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Start simple : The simplest example adds only 2 lines of code to your app: 1 import, 1 function call . Grow large : Grow in complexity as much as you want, create arbitrarily complex trees of commands and groups subcommands, with options and arguments. Requirements \u00b6 Python 3.6+ Typer stands on the shoulders of a giant. Its only internal dependency is Click . Installation \u00b6 $ pip install typer ---> 100% Successfully installed typer Example \u00b6 The absolute minimum \u00b6 Create a file main.py with: import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main ) Run it \u00b6 Run your application: // Run your application $ python main.py // You get a nice error, you are missing NAME Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // You get a --help for free $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // You get \u2728 auto completion \u2728 for free, installed with --install-completion // Now pass the NAME argument $ python main.py Camila Hello Camila // It works! \ud83c\udf89 Example upgrade \u00b6 This was the simplest example possible. Now let's see one a bit more complex. An example with two subcommands \u00b6 Modify the file main.py . Create a typer.Typer() app, and create two subcommands with their parameters. import typer app = typer . Typer () @app . command () def hello ( name : str ): typer . echo ( f \"Hello {name} \" ) @app . command () def goodbye ( name : str , formal : bool = False ): if formal : typer . echo ( f \"Goodbye Ms. {name} . Have a good day.\" ) else : typer . echo ( f \"Bye {name} !\" ) if __name__ == \"__main__\" : app () And that will: Explicitly create a typer.Typer app. The previous typer.run actually creates one implicitly for you. Add two subcommands with @app.command() . Execute the app() itself, as if it was a function (instead of typer.run ). Run the upgraded example \u00b6 // Check the --help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: goodbye hello // You have 2 subcommands (the 2 functions): goodbye and hello // Now get the --help for hello $ python main.py hello --help Usage: main.py hello [OPTIONS] NAME Options: --help Show this message and exit. // And now get the --help for goodbye $ python main.py goodbye --help Usage: main.py goodbye [OPTIONS] NAME Options: --formal / --no-formal --help Show this message and exit. // Automatic --formal and --no-formal for the bool option \ud83c\udf89 // And if you use it with the hello command $ python main.py hello Camila Hello Camila // And with the goodbye command $ python main.py goodbye Camila Bye Camila! // And with --formal $ python main.py goodbye --formal Camila Goodbye Ms. Camila. Have a good day. Recap \u00b6 In summary, you declare once the types of parameters ( arguments and options ) as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python 3.6+ . For example, for an int : total : int or for a bool flag: force : bool And similarly for files , paths , enums (choices), etc. And there are tools to create groups of subcommands , add metadata, extra validation , etc. You get : great editor support, including completion and type checks everywhere. Your users get : automatic --help , (optional) autocompletion in their terminal (Bash, Zsh, Fish, PowerShell). For a more complete example including more features, see the Tutorial - User Guide . Optional Dependencies \u00b6 Typer uses Click internally. That's the only dependency. But you can also install extras: colorama : and Click will automatically use it to make sure your terminal's colors always work correctly, even in Windows. Then you can use any tool you want to output your terminal's colors in all the systems, including the integrated typer.style() and typer.secho() (provided by Click). Or any other tool, e.g. wasabi , blessings . click-completion : and Typer will automatically configure it to provide completion for all the shells, including installation commands. You can install typer with colorama and click-completion with pip install typer[all] . Other tools and plug-ins \u00b6 Click has many plug-ins available that you can use. And there are many tools that help with command line applications that you can use as well, even if they are not related to Typer or Click. For example: click-spinner : to show the user that you are loading data. A Click plug-in. There are several other Click plug-ins at click-contrib that you can explore. tabulate : to automatically display tabular data nicely. Independent of Click or typer. etc... you can re-use many of the great available tools for building CLIs. License \u00b6 This project is licensed under the terms of the MIT license.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+ Typer stands on the shoulders of a giant. Its only internal dependency is Click .","title":"Requirements"},{"location":"#installation","text":"$ pip install typer ---> 100% Successfully installed typer","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#the-absolute-minimum","text":"Create a file main.py with: import typer def main ( name : str ): typer . echo ( f \"Hello {name} \" ) if __name__ == \"__main__\" : typer . run ( main )","title":"The absolute minimum"},{"location":"#run-it","text":"Run your application: // Run your application $ python main.py // You get a nice error, you are missing NAME Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument \"NAME\". // You get a --help for free $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // You get \u2728 auto completion \u2728 for free, installed with --install-completion // Now pass the NAME argument $ python main.py Camila Hello Camila // It works! \ud83c\udf89","title":"Run it"},{"location":"#example-upgrade","text":"This was the simplest example possible. Now let's see one a bit more complex.","title":"Example upgrade"},{"location":"#an-example-with-two-subcommands","text":"Modify the file main.py . Create a typer.Typer() app, and create two subcommands with their parameters. import typer app = typer . Typer () @app . command () def hello ( name : str ): typer . echo ( f \"Hello {name} \" ) @app . command () def goodbye ( name : str , formal : bool = False ): if formal : typer . echo ( f \"Goodbye Ms. {name} . Have a good day.\" ) else : typer . echo ( f \"Bye {name} !\" ) if __name__ == \"__main__\" : app () And that will: Explicitly create a typer.Typer app. The previous typer.run actually creates one implicitly for you. Add two subcommands with @app.command() . Execute the app() itself, as if it was a function (instead of typer.run ).","title":"An example with two subcommands"},{"location":"#run-the-upgraded-example","text":"// Check the --help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: goodbye hello // You have 2 subcommands (the 2 functions): goodbye and hello // Now get the --help for hello $ python main.py hello --help Usage: main.py hello [OPTIONS] NAME Options: --help Show this message and exit. // And now get the --help for goodbye $ python main.py goodbye --help Usage: main.py goodbye [OPTIONS] NAME Options: --formal / --no-formal --help Show this message and exit. // Automatic --formal and --no-formal for the bool option \ud83c\udf89 // And if you use it with the hello command $ python main.py hello Camila Hello Camila // And with the goodbye command $ python main.py goodbye Camila Bye Camila! // And with --formal $ python main.py goodbye --formal Camila Goodbye Ms. Camila. Have a good day.","title":"Run the upgraded example"},{"location":"#recap","text":"In summary, you declare once the types of parameters ( arguments and options ) as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python 3.6+ . For example, for an int : total : int or for a bool flag: force : bool And similarly for files , paths , enums (choices), etc. And there are tools to create groups of subcommands , add metadata, extra validation , etc. You get : great editor support, including completion and type checks everywhere. Your users get : automatic --help , (optional) autocompletion in their terminal (Bash, Zsh, Fish, PowerShell). For a more complete example including more features, see the Tutorial - User Guide .","title":"Recap"},{"location":"#optional-dependencies","text":"Typer uses Click internally. That's the only dependency. But you can also install extras: colorama : and Click will automatically use it to make sure your terminal's colors always work correctly, even in Windows. Then you can use any tool you want to output your terminal's colors in all the systems, including the integrated typer.style() and typer.secho() (provided by Click). Or any other tool, e.g. wasabi , blessings . click-completion : and Typer will automatically configure it to provide completion for all the shells, including installation commands. You can install typer with colorama and click-completion with pip install typer[all] .","title":"Optional Dependencies"},{"location":"#other-tools-and-plug-ins","text":"Click has many plug-ins available that you can use. And there are many tools that help with command line applications that you can use as well, even if they are not related to Typer or Click. For example: click-spinner : to show the user that you are loading data. A Click plug-in. There are several other Click plug-ins at click-contrib that you can explore. tabulate : to automatically display tabular data nicely. Independent of Click or typer. etc... you can re-use many of the great available tools for building CLIs.","title":"Other tools and plug-ins"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"contributing/","text":"First, you might want to see the basic ways to help Typer and get help . Coming soon...","title":"Development - Contributing"},{"location":"features/","text":"Design based on FastAPI \u00b6 Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less. Just Modern Python \u00b6 It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . Editor support \u00b6 Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc. Short \u00b6 It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" . User friendly CLI apps \u00b6 The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work. The power of Click \u00b6 Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"Features"},{"location":"features/#design-based-on-fastapi","text":"Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less.","title":"Design based on FastAPI"},{"location":"features/#just-modern-python","text":"It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro .","title":"Just Modern Python"},{"location":"features/#editor-support","text":"Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc.","title":"Editor support"},{"location":"features/#short","text":"It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" .","title":"Short"},{"location":"features/#user-friendly-cli-apps","text":"The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work.","title":"User friendly CLI apps"},{"location":"features/#the-power-of-click","text":"Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"The power of Click"},{"location":"release-notes/","text":"Latest changes \u00b6 Update format for internal links. PR #38 . Tweak external links' format. PR #36 . 0.0.8 \u00b6 Update docs and add latest changes to MkDocs/website. PR #33 . Add extra tests for edge cases that don't belong in docs' examples. PR #32 . Add docs for CLI Parameters with Multiple Values . Includes tests for all the examples and bug fixes. PR #31 . Add docs for extra CLI parameter types: CLI Parameter Types: Number and CLI Parameter Types: Boolean CLI Options . PR #30 . Extend docs for Commands, add Commands: Typer Callback and Commands: One or Multiple . This includes tests for all the examples and bug fixes. PR #29 . Add docs for SubCommands - Command Groups . This includes tests for all the examples and bug fixes. PR #28 . Remove unneeded code for argument handling. PR #26 . Add docs for Launching Applications . PR #25 . Add docs for getting the CLI Application Directory . PR #24 . Add docs for Progress Bars . PR #23 . Add docs for Asking with Interactive Prompts . PR #22 . Update docs for path CLI option . PR #21 . Add colors module and docs for Printing and Colors and for Terminating , including tests. PR #20 . Refactor docs to make each individual page/section \"bite-sized\" / small. Add docs for CLI option names . Update typer.Argument() to remove invalid positional param_decls . PR #19 . 0.0.7 \u00b6 Add docs for CLI parameter types . Includes tests and file classes refactor. PR #17 . Add tests for completion. PR #15 and #16 . 0.0.6 \u00b6 Add docs for Commands . Includes a bug fix for handling default values set in typer.Typer() parameters. PR #14 . Add docs for CLI Arguments . PR #13 . Add docs for CLI Options . PR #12 . 0.0.5 \u00b6 Clean exports from Typer. Remove unneeded components from Click and add needed Exit exception. PR #11 . Fix and document extracting help from a function's docstring First Steps: Document your CLI app . PR #10 . Update references to --install-completion and --show-completion in docs. PR #9 . Fix testing utilities, add tests for First Steps examples. PR #8 . Add auto completion options by default when click-completion is installed: --install-completion and --show-completion . PR #7 . Update Termynal to have fixed sizes, add \"fast\" button, and use it in First Steps . PR #6 . Add custom automatic Termynal for docs. PR #5 . 0.0.4 \u00b6 Update short descriptions and assets. Docs rewording and fix typos. PR #1 by @mariacamilagl . 0.0.3 \u00b6 Fix group creation without name. 0.0.2 \u00b6 Add initial version of code, docs, etc. 0.0.1 \u00b6 First commit. Publish to PyPI to reserve package name.","title":"Release Notes"},{"location":"release-notes/#latest-changes","text":"Update format for internal links. PR #38 . Tweak external links' format. PR #36 .","title":"Latest changes"},{"location":"release-notes/#008","text":"Update docs and add latest changes to MkDocs/website. PR #33 . Add extra tests for edge cases that don't belong in docs' examples. PR #32 . Add docs for CLI Parameters with Multiple Values . Includes tests for all the examples and bug fixes. PR #31 . Add docs for extra CLI parameter types: CLI Parameter Types: Number and CLI Parameter Types: Boolean CLI Options . PR #30 . Extend docs for Commands, add Commands: Typer Callback and Commands: One or Multiple . This includes tests for all the examples and bug fixes. PR #29 . Add docs for SubCommands - Command Groups . This includes tests for all the examples and bug fixes. PR #28 . Remove unneeded code for argument handling. PR #26 . Add docs for Launching Applications . PR #25 . Add docs for getting the CLI Application Directory . PR #24 . Add docs for Progress Bars . PR #23 . Add docs for Asking with Interactive Prompts . PR #22 . Update docs for path CLI option . PR #21 . Add colors module and docs for Printing and Colors and for Terminating , including tests. PR #20 . Refactor docs to make each individual page/section \"bite-sized\" / small. Add docs for CLI option names . Update typer.Argument() to remove invalid positional param_decls . PR #19 .","title":"0.0.8"},{"location":"release-notes/#007","text":"Add docs for CLI parameter types . Includes tests and file classes refactor. PR #17 . Add tests for completion. PR #15 and #16 .","title":"0.0.7"},{"location":"release-notes/#006","text":"Add docs for Commands . Includes a bug fix for handling default values set in typer.Typer() parameters. PR #14 . Add docs for CLI Arguments . PR #13 . Add docs for CLI Options . PR #12 .","title":"0.0.6"},{"location":"release-notes/#005","text":"Clean exports from Typer. Remove unneeded components from Click and add needed Exit exception. PR #11 . Fix and document extracting help from a function's docstring First Steps: Document your CLI app . PR #10 . Update references to --install-completion and --show-completion in docs. PR #9 . Fix testing utilities, add tests for First Steps examples. PR #8 . Add auto completion options by default when click-completion is installed: --install-completion and --show-completion . PR #7 . Update Termynal to have fixed sizes, add \"fast\" button, and use it in First Steps . PR #6 . Add custom automatic Termynal for docs. PR #5 .","title":"0.0.5"},{"location":"release-notes/#004","text":"Update short descriptions and assets. Docs rewording and fix typos. PR #1 by @mariacamilagl .","title":"0.0.4"},{"location":"release-notes/#003","text":"Fix group creation without name.","title":"0.0.3"},{"location":"release-notes/#002","text":"Add initial version of code, docs, etc.","title":"0.0.2"},{"location":"release-notes/#001","text":"First commit. Publish to PyPI to reserve package name.","title":"0.0.1"},{"location":"api/dataset/","text":"","title":"Dataset"},{"location":"api/insights/","text":"","title":"Insights"},{"location":"api/stats/","text":"spacy_data_debug.stats \u00b6 The stats module implements utility functions for getting statistics for an NER dataset. It's useful for getting a quick overview of your data and checking that you have enough examples for each label (including examples with NO ENTITIES ) API \u00b6 spacy_data_debug.stats. ner_stats ( data , serialize=False , no_print=False ) Compute statistics for NER data Parameters \u00b6 data : (List[Example]), required. Data as a List of Examples serialize : (bool, optional), Defaults to False. Serialize to a JSON string for printing no_print : (bool, optional), Defaults to False. Don't print, return serialized string. Requires serialize to be True Returns \u00b6 (List[Example]): List of examples or string if serialize and no_print are both True","title":"Stats"},{"location":"api/stats/#spacy_data_debugstats","text":"The stats module implements utility functions for getting statistics for an NER dataset. It's useful for getting a quick overview of your data and checking that you have enough examples for each label (including examples with NO ENTITIES )","title":"spacy_data_debug.stats"},{"location":"api/stats/#api","text":"spacy_data_debug.stats. ner_stats ( data , serialize=False , no_print=False ) Compute statistics for NER data","title":"API"},{"location":"api/validation/","text":"spacy_data_debug.validation \u00b6 spacy_data_debug.validation provides a set of utility functions to fix and validate annotations to ensure consistency and no overlapping entities are set. These functions are useful to run before any of the functionality in spacy_data_debug.insights or spacy_data_debug.stats . API \u00b6 spacy_data_debug.validation. json_to_examples ( data ) Convert List of Dicts to List of typed Examples Parameters \u00b6 data : (List[Dict[str, Any]]), required. Input List of Dicts to convert Returns \u00b6 (List[Example]): List of typed Examples spacy_data_debug.validation. fix_annotations_format ( data ) Fix annotations format for a consistent dataset Parameters \u00b6 data : (List[Dict[str, Any]]), required. List of Examples Returns \u00b6 (List[Dict[str, Any]]): List of Examples with corrected formatting spacy_data_debug.validation. filter_overlaps ( data ) Filter overlapping entity spans by picking the longest one. Parameters \u00b6 data : (List[Dict[str, Any]]), required. List of Examples Returns \u00b6 (List[Dict[str, Any]]): List of Examples with fixed overlaps","title":"Validation"},{"location":"api/validation/#spacy_data_debugvalidation","text":"spacy_data_debug.validation provides a set of utility functions to fix and validate annotations to ensure consistency and no overlapping entities are set. These functions are useful to run before any of the functionality in spacy_data_debug.insights or spacy_data_debug.stats .","title":"spacy_data_debug.validation"},{"location":"api/validation/#api","text":"spacy_data_debug.validation. json_to_examples ( data ) Convert List of Dicts to List of typed Examples","title":"API"}]}