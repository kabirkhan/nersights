{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"`reconer`, Debug annotated Named Entity Recognition (NER) data for inconsitencies and get insights on improving the quality of your data. Documentation : https://kabirkhan.github.io/reconer Source Code : https://github.com/kabirkhan/reconer RecoNER is a library to help you fix your annotated NER data and identify examples that are hardest for your model to predict so you can strategically prioritize the examples you annotate. The key features are: Data Validation and Cleanup : Easily Validate the format of your NER data. Filter overlapping Entity Annotations, fix missing properties. Model Insights : Analyze how well your model does on your Dataset. Identify the top errors your model is making so you can prioritize data collection and correction strategically. Model Insights : Analyze how well your model does on your Dataset. Identify the top errors your model is making so you can prioritize data collection and correction strategically. Dataset Management : reconer provides a Dataset class to manage the train/dev/test split of your data and apply the same functions across all splits in your data + a concatenation of all examples. Operate inplace to consistently transform your data. Serializable Dataset : Serialize and Deserialize your data to and from JSON to the reconer type system. Type Hints : Comprehensive Typing system based on Python 3.6+ Type Hints Requirements \u00b6 Python 3.6+ Python 3.6+ RecoNER is built on a few comprehensive, high-performing packages. spaCy Pydantic (Type system and JSON Serialization) Typer (CLI) . Installation \u00b6 $ pip install reconer ---> 100% Successfully installed reconer License \u00b6 This project is licensed under the terms of the MIT license.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+ Python 3.6+ RecoNER is built on a few comprehensive, high-performing packages. spaCy Pydantic (Type system and JSON Serialization) Typer (CLI) .","title":"Requirements"},{"location":"#installation","text":"$ pip install reconer ---> 100% Successfully installed reconer","title":"Installation"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"contributing/","text":"First, you might want to see the basic ways to help Typer and get help . Coming soon...","title":"Development - Contributing"},{"location":"features/","text":"Design based on FastAPI \u00b6 Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less. Just Modern Python \u00b6 It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . Editor support \u00b6 Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc. Short \u00b6 It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" . User friendly CLI apps \u00b6 The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work. The power of Click \u00b6 Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"Features"},{"location":"features/#design-based-on-fastapi","text":"Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI, you already know Typer ... more or less.","title":"Design based on FastAPI"},{"location":"features/#just-modern-python","text":"It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro .","title":"Just Modern Python"},{"location":"features/#editor-support","text":"Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc.","title":"Editor support"},{"location":"features/#short","text":"It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" .","title":"Short"},{"location":"features/#user-friendly-cli-apps","text":"The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all the its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic autocompletion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Autocompletion For the autocompletion to work on all shells you also need to add the dependency click-completion . Just that. And Typer does the rest. If Typer detects click-completion installed, it will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. Then you can tell the user to run that command and the rest will just work.","title":"User friendly CLI apps"},{"location":"features/#the-power-of-click","text":"Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"The power of Click"},{"location":"release-notes/","text":"0.0.1 \u00b6 First commit. Publish to PyPI to reserve package name. Initial Functionality for Validation, Insights, Dataset Managment, Serialization and Deserialization from JSON files, Type System","title":"Release Notes"},{"location":"release-notes/#001","text":"First commit. Publish to PyPI to reserve package name. Initial Functionality for Validation, Insights, Dataset Managment, Serialization and Deserialization from JSON files, Type System","title":"0.0.1"},{"location":"api/dataset/","text":"","title":"Dataset"},{"location":"api/insights/","text":"","title":"Insights"},{"location":"api/stats/","text":"reconer.stats \u00b6 The stats module implements utility functions for getting statistics for an NER dataset. It's useful for getting a quick overview of your data and checking that you have enough examples for each label (including examples with NO ENTITIES ) API \u00b6 reconer.stats. ner_stats ( data , serialize=False , no_print=False ) Compute statistics for NER data Parameters \u00b6 data : (List[Example]), required. Data as a List of Examples serialize : (bool, optional), Defaults to False. Serialize to a JSON string for printing no_print : (bool, optional), Defaults to False. Don't print, return serialized string. Requires serialize to be True Returns \u00b6 (List[Example]): List of examples or string if serialize and no_print are both True","title":"Stats"},{"location":"api/stats/#reconerstats","text":"The stats module implements utility functions for getting statistics for an NER dataset. It's useful for getting a quick overview of your data and checking that you have enough examples for each label (including examples with NO ENTITIES )","title":"reconer.stats"},{"location":"api/stats/#api","text":"reconer.stats. ner_stats ( data , serialize=False , no_print=False ) Compute statistics for NER data","title":"API"},{"location":"api/validation/","text":"reconer.validation \u00b6 reconer.validation provides a set of utility functions to fix and validate annotations to ensure consistency and no overlapping entities are set. These functions are useful to run before any of the functionality in reconer.insights or reconer.stats . API \u00b6 reconer.validation. json_to_examples ( data ) Convert List of Dicts to List of typed Examples Parameters \u00b6 data : (List[Dict[str, Any]]), required. Input List of Dicts to convert Returns \u00b6 (List[Example]): List of typed Examples reconer.validation. fix_annotations_format ( data ) Fix annotations format for a consistent dataset Parameters \u00b6 data : (List[Dict[str, Any]]), required. List of Examples Returns \u00b6 (List[Dict[str, Any]]): List of Examples with corrected formatting reconer.validation. filter_overlaps ( data ) Filter overlapping entity spans by picking the longest one. Parameters \u00b6 data : (List[Dict[str, Any]]), required. List of Examples Returns \u00b6 (List[Dict[str, Any]]): List of Examples with fixed overlaps","title":"Validation"},{"location":"api/validation/#reconervalidation","text":"reconer.validation provides a set of utility functions to fix and validate annotations to ensure consistency and no overlapping entities are set. These functions are useful to run before any of the functionality in reconer.insights or reconer.stats .","title":"reconer.validation"},{"location":"api/validation/#api","text":"reconer.validation. json_to_examples ( data ) Convert List of Dicts to List of typed Examples","title":"API"}]}